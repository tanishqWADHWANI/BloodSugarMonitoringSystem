================================================================================
              SERVER ARCHITECTURE & API DESIGN
================================================================================
                Blood Sugar Monitoring System
                Technical Documentation
================================================================================

OVERVIEW
--------
The system uses Flask as the backend web framework to provide RESTful API 
endpoints. The server handles authentication, data management, file uploads,
machine learning predictions, and automated notifications.

Server Framework: Flask (Python)
Server Port: 5000
Server Host: 127.0.0.1 (localhost)
API Base URL: http://127.0.0.1:5000


================================================================================
SERVER INITIALIZATION & STARTUP
================================================================================

MAIN APPLICATION FILE: backend/app.py
--------------------------------------

1. IMPORTS & DEPENDENCIES
--------------------------
   from flask import Flask, request, jsonify
   from flask_cors import CORS
   from models import Database
   from ml_service import MLService
   from notification_service import NotificationService
   from scheduler_service import SchedulerService
   
   Core Dependencies:
   - Flask: Web framework and routing
   - Flask-CORS: Cross-Origin Resource Sharing for frontend access
   - mysql-connector-python: Database connectivity
   - scikit-learn: Machine learning models
   - pandas: Data analysis
   - APScheduler: Background task scheduling


2. APPLICATION INITIALIZATION
------------------------------
   app = Flask(__name__)
   CORS(app)  # Enable CORS for all routes
   
   # Initialize services
   db = Database()
   ml_service = MLService()
   notification_service = NotificationService()
   scheduler = SchedulerService(db, notification_service)
   scheduler.start()

Services Initialized at Startup:
   ✓ Database: Establishes MySQL connection
   ✓ ML Service: Loads trained models or falls back to rules
   ✓ Notification Service: Configures SMTP email settings
   ✓ Scheduler Service: Starts background jobs for alerts


3. SERVER STARTUP
-----------------
   if __name__ == '__main__':
       app.run(
           host='127.0.0.1',
           port=5000,
           debug=True  # Development mode with auto-reload
       )

Configuration Details:
   - Host: 127.0.0.1 (localhost only, not exposed externally)
   - Port: 5000 (Flask default development port)
   - Debug Mode: Enabled for development (shows detailed errors)
   - Auto-reload: Code changes trigger automatic restart


================================================================================
API ENDPOINT ARCHITECTURE
================================================================================

ENDPOINT CATEGORIES (40+ endpoints)
-----------------------------------

1. AUTHENTICATION & SESSION MANAGEMENT
   POST   /api/login                    - User login (all roles)
   POST   /api/auth/login               - Alternative login endpoint
   GET    /api/me                       - Get current user info

2. USER MANAGEMENT
   POST   /api/users/register           - Patient self-registration
   GET    /api/users/<id>               - Get user by ID
   PUT    /api/users/<id>               - Update user profile
   DELETE /api/users/<id>               - Delete user account
   POST   /api/admin/users              - Admin create user
   GET    /api/admin/users/all          - Admin view all users
   DELETE /api/admin/users/<id>         - Admin delete user

3. BLOOD SUGAR READINGS
   POST   /api/readings                 - Add new reading
   GET    /api/readings/<user_id>       - Get user's readings
   PUT    /api/readings/<reading_id>    - Update reading
   DELETE /api/readings/<reading_id>    - Delete reading
   GET    /api/specialist/<id>/readings/search - Search patient readings

4. AI INSIGHTS & ANALYTICS
   GET    /api/insights/<user_id>       - Get AI insights
   GET    /api/aiinsights/<user_id>     - Get saved AI insights
   GET    /api/insights/<user_id>/trends - Get glucose trends
   GET    /api/insights/<user_id>/patterns - Get glucose patterns
   GET    /api/alerts/<user_id>         - Get user alerts

5. SPECIALIST FEATURES
   GET    /api/specialist/<id>/patients - Get assigned patients
   GET    /api/specialist/<id>/dashboard - Specialist dashboard data
   GET    /api/specialist/<id>/attention - Patients needing attention
   GET    /api/specialist/alerts/<id>   - Specialist alerts
   POST   /api/specialist/feedback      - Add patient feedback
   GET    /api/patient/<id>/feedback    - Get patient feedback
   GET    /api/patient/<id>/specialist  - Get assigned specialist

6. THRESHOLD MANAGEMENT
   GET    /api/thresholds/<user_id>     - Get user thresholds
   POST   /api/thresholds/<user_id>     - Set user threshold
   GET    /api/thresholds               - Get all thresholds (admin)
   DELETE /api/thresholds/<id>          - Delete threshold

7. REPORTS & ANALYTICS
   GET    /api/reports/<user_id>        - Generate user report
   GET    /api/admin/reports/monthly    - Monthly system report
   GET    /api/admin/reports/annual     - Annual system report

8. DIET RECOMMENDATIONS
   GET    /api/diet/<condition>         - Get diet recommendations

9. USER LISTS
   GET    /api/patients                 - Get all patients
   GET    /api/specialists              - Get all specialists

10. HEALTH & DIAGNOSTICS
    GET    /api/health                   - Health check endpoint
    GET    /api/test/database            - Test database connection


================================================================================
REQUEST/RESPONSE FLOW
================================================================================

TYPICAL API REQUEST FLOW
-------------------------

1. CLIENT REQUEST (Frontend → Backend)
   ┌─────────────────────────────────────────────────────┐
   │ HTTP Request from browser                          │
   │ Method: POST                                       │
   │ URL: http://127.0.0.1:5000/api/readings           │
   │ Headers:                                           │
   │   - Content-Type: application/json                │
   │   - Authorization: Bearer <token>                 │
   │ Body:                                              │
   │   {                                                │
   │     "value": 125,                                  │
   │     "fasting": true,                               │
   │     "food_intake": "breakfast"                     │
   │   }                                                │
   └─────────────────────────────────────────────────────┘
                          ↓
2. FLASK ROUTING
   ┌─────────────────────────────────────────────────────┐
   │ Flask receives request                             │
   │ Matches route: @app.route('/api/readings')        │
   │ Calls handler function: add_reading()             │
   └─────────────────────────────────────────────────────┘
                          ↓
3. AUTHENTICATION CHECK
   ┌─────────────────────────────────────────────────────┐
   │ Extract token from Authorization header            │
   │ Validate token format and signature               │
   │ Get user_id from token payload                    │
   │ If invalid: Return 401 Unauthorized               │
   └─────────────────────────────────────────────────────┘
                          ↓
4. BUSINESS LOGIC
   ┌─────────────────────────────────────────────────────┐
   │ Parse request JSON data                            │
   │ Validate input parameters                          │
   │ Call Database methods                              │
   │ Call ML Service for analysis                       │
   │ Process results                                    │
   └─────────────────────────────────────────────────────┘
                          ↓
5. DATABASE OPERATIONS
   ┌─────────────────────────────────────────────────────┐
   │ Execute SQL queries via Database class             │
   │ INSERT reading into readings table                 │
   │ Check thresholds                                   │
   │ Create alerts if needed                            │
   │ COMMIT transaction                                 │
   └─────────────────────────────────────────────────────┘
                          ↓
6. ML ANALYSIS (if applicable)
   ┌─────────────────────────────────────────────────────┐
   │ MLService.predict_status()                         │
   │ Classify reading (normal/high/low/prediabetic)   │
   │ Generate insights and recommendations             │
   │ Store in ai_insights table                        │
   └─────────────────────────────────────────────────────┘
                          ↓
7. RESPONSE GENERATION
   ┌─────────────────────────────────────────────────────┐
   │ Format response as JSON                            │
   │ Add appropriate HTTP status code                   │
   │ Include success/error messages                     │
   │ Return to client                                   │
   └─────────────────────────────────────────────────────┘
                          ↓
8. CLIENT RECEIVES RESPONSE
   ┌─────────────────────────────────────────────────────┐
   │ Status: 201 Created                                │
   │ Body:                                              │
   │   {                                                │
   │     "success": true,                               │
   │     "reading_id": 1234,                            │
   │     "status": "normal",                            │
   │     "insights": [...],                             │
   │     "message": "Reading added successfully"        │
   │   }                                                │
   └─────────────────────────────────────────────────────┘


================================================================================
AUTHENTICATION MECHANISM
================================================================================

TOKEN-BASED AUTHENTICATION
---------------------------

1. LOGIN PROCESS
   User submits credentials → Server validates → Generates token
   
   Token Format: Simple user_id based token (Custom implementation)
   Storage: Client stores token in localStorage
   Usage: Sent in Authorization header for subsequent requests

2. TOKEN VALIDATION
   def get_user_from_token():
       """Extract user info from authorization token"""
       auth_header = request.headers.get('Authorization')
       if not auth_header:
           return None
       
       try:
           token = auth_header.split(' ')[1]  # Bearer <token>
           # Decode token and extract user_id
           user_id = decode_token(token)
           return db.get_user(user_id)
       except:
           return None

3. PROTECTED ROUTES
   Every protected endpoint calls get_user_from_token():
   
   @app.route('/api/readings', methods=['POST'])
   def add_reading():
       user = get_user_from_token()
       if not user:
           return jsonify({'error': 'Unauthorized'}), 401
       
       # Process request...

4. ROLE-BASED ACCESS CONTROL
   Different roles have different permissions:
   
   - Patient: Own data access only
   - Specialist: Assigned patients' data
   - Staff: All patient data (read-only)
   - Admin: Full system access


================================================================================
ERROR HANDLING & LOGGING
================================================================================

STANDARDIZED ERROR RESPONSES
-----------------------------

Success Response (200-299):
   {
       "success": true,
       "data": {...},
       "message": "Operation successful"
   }

Client Error (400-499):
   {
       "success": false,
       "error": "Invalid input",
       "details": "Blood sugar value must be positive"
   }

Server Error (500-599):
   {
       "success": false,
       "error": "Internal server error",
       "message": "An unexpected error occurred"
   }

HTTP STATUS CODES USED
----------------------
   200 OK              - Successful GET request
   201 Created         - Resource created successfully
   400 Bad Request     - Invalid input data
   401 Unauthorized    - Missing or invalid authentication
   403 Forbidden       - Insufficient permissions
   404 Not Found       - Resource doesn't exist
   500 Internal Error  - Server-side error

LOGGING CONFIGURATION
---------------------
   import logging
   
   logging.basicConfig(
       level=logging.INFO,
       format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
   )
   
   logger = logging.getLogger(__name__)

Logged Events:
   - Database connections/disconnections
   - Authentication attempts
   - API requests and responses
   - ML model predictions
   - Email notifications sent
   - Scheduler job executions
   - Errors and exceptions


================================================================================
FILE UPLOAD HANDLING
================================================================================

PROFILE IMAGES & MEDICAL RECORDS
---------------------------------

1. ALLOWED FILE TYPES
   ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif', 'pdf', 'doc', 'docx'}
   
   def allowed_file(filename):
       return '.' in filename and \
              filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

2. UPLOAD DIRECTORY
   UPLOAD_FOLDER = 'backend/uploads'
   app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
   app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16 MB max

3. UPLOAD PROCESS
   @app.route('/api/upload/profile', methods=['POST'])
   def upload_profile_image():
       if 'file' not in request.files:
           return jsonify({'error': 'No file provided'}), 400
       
       file = request.files['file']
       if file and allowed_file(file.filename):
           filename = secure_filename(file.filename)
           filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
           file.save(filepath)
           
           # Store path in database
           db.update_user(user_id, profile_image_path=filepath)

4. FILE SERVING
   Uploaded files served statically:
   - URL: /uploads/<filename>
   - Storage: backend/uploads/ directory
   - Access control: User authentication required


================================================================================
CORS CONFIGURATION
================================================================================

CROSS-ORIGIN RESOURCE SHARING
------------------------------

Purpose: Allow frontend (HTML files) to call backend API

Configuration:
   from flask_cors import CORS
   CORS(app)  # Enable CORS for all routes

What CORS Enables:
   ✓ Frontend on file:// protocol can access API
   ✓ Future deployment on different domains
   ✓ Mobile app API access
   ✓ Third-party integrations

Headers Added:
   Access-Control-Allow-Origin: *
   Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS
   Access-Control-Allow-Headers: Content-Type, Authorization


================================================================================
BACKGROUND SERVICES
================================================================================

SCHEDULER SERVICE
-----------------
Runs automated tasks in the background without blocking API requests.

Scheduled Jobs:
   1. Check Notifications (Hourly)
      - Scan all patients for abnormal readings
      - Send email alerts if thresholds breached
      - Notify assigned specialists

   2. Future Jobs (Expandable)
      - Daily summary reports
      - Weekly trend analysis
      - Database cleanup
      - Backup operations

Implementation:
   from apscheduler.schedulers.background import BackgroundScheduler
   
   scheduler = BackgroundScheduler()
   scheduler.add_job(
       func=check_all_notifications,
       trigger='interval',
       hours=1
   )
   scheduler.start()


================================================================================
PERFORMANCE CONSIDERATIONS
================================================================================

OPTIMIZATION STRATEGIES
-----------------------

1. Database Query Optimization
   - Use indexed columns in WHERE clauses
   - Fetch only required columns (not SELECT *)
   - Batch operations when possible
   - Connection reuse via class instance

2. Caching Strategy
   - User session data cached in memory
   - ML model loaded once at startup
   - Frequent queries cached temporarily

3. Asynchronous Operations
   - Email sending done in background
   - ML analysis doesn't block response
   - Scheduler runs independently

4. Response Time Targets
   - Authentication: < 100ms
   - Simple queries: < 200ms
   - ML predictions: < 500ms
   - Report generation: < 2s


================================================================================
SECURITY MEASURES
================================================================================

APPLICATION SECURITY
--------------------

1. Input Validation
   - All user inputs sanitized
   - Type checking on parameters
   - SQL injection prevention (parameterized queries)
   - File upload restrictions

2. Authentication Security
   - Password hashing (SHA-256)
   - Token-based session management
   - Session expiration (recommended)
   - HTTPS enforcement (production)

3. Authorization
   - Role-based access control
   - User can only access own data
   - Specialist limited to assigned patients
   - Admin has audit trail

4. Data Protection
   - Sensitive data not logged
   - Database credentials in environment variables
   - No credentials in source code
   - Medical records access controlled


================================================================================
DEPLOYMENT CONSIDERATIONS
================================================================================

DEVELOPMENT VS PRODUCTION
--------------------------

Current (Development):
   - Debug mode enabled
   - Host: 127.0.0.1 (localhost only)
   - Port: 5000
   - Single-threaded
   - Development database

Production Recommendations:
   - Use production WSGI server (Gunicorn/uWSGI)
   - Deploy behind reverse proxy (Nginx)
   - HTTPS/SSL certificates
   - Environment-based configuration
   - Database connection pooling
   - Load balancing
   - Monitoring and logging
   - Automated backups

Production Startup Example:
   gunicorn -w 4 -b 0.0.0.0:8000 app:app


================================================================================
API DOCUMENTATION EXAMPLE
================================================================================

ENDPOINT: Add Blood Sugar Reading
----------------------------------

URL: POST /api/readings

Headers:
   Content-Type: application/json
   Authorization: Bearer <token>

Request Body:
   {
       "value": 125,
       "unit": "mg/dL",
       "fasting": true,
       "food_intake": "Oatmeal with berries",
       "activity": "Morning walk - 30 mins",
       "symptoms": "None",
       "notes": "Feeling good today"
   }

Response (201 Created):
   {
       "success": true,
       "reading_id": 1234,
       "status": "normal",
       "insights": [
           {
               "type": "success",
               "message": "Blood sugar is normal (125 mg/dL). Keep it up!",
               "priority": "low"
           }
       ],
       "message": "Reading added successfully"
   }

Error Response (401 Unauthorized):
   {
       "success": false,
       "error": "Unauthorized",
       "message": "Invalid or missing authentication token"
   }


================================================================================
CONCLUSION
================================================================================

The Flask server architecture provides a robust, scalable REST API for the
Blood Sugar Monitoring System. With 40+ endpoints, comprehensive error 
handling, background task scheduling, and integrated ML analysis, it serves
as the central hub for all application functionality.

Key Strengths:
   ✓ RESTful API design
   ✓ Token-based authentication
   ✓ Role-based access control
   ✓ Integrated ML service
   ✓ Background task scheduling
   ✓ Comprehensive error handling
   ✓ File upload support
   ✓ Email notification system
   ✓ CORS enabled for frontend
   ✓ Production-ready architecture

The server operates on port 5000 (NOT to be confused with database port 3306)
and communicates with the MySQL database on port 3306 for all data operations.

================================================================================
