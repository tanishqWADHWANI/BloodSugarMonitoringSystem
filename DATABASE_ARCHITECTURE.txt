================================================================================
              DATABASE ARCHITECTURE & CONNECTION GUIDE
================================================================================
                Blood Sugar Monitoring System
                Technical Documentation
================================================================================

OVERVIEW
--------
The system uses MySQL/MariaDB as the primary database for storing all 
application data including user accounts, blood sugar readings, medical 
records, thresholds, and AI-generated insights.

Database Name: blood_sugar_db
Database Port: 3306 (MySQL default)
Connection Type: Direct connection using mysql-connector-python


================================================================================
DATABASE CONNECTION PROCESS
================================================================================

1. CONNECTION INITIALIZATION
-----------------------------
Location: backend/models.py - Database class

The Database class establishes connection on initialization:

   def __init__(self):
       """Initialize database connection"""
       self.connection = None
       self.connect()

Environment Variables Used:
   - DB_HOST: Database server address (default: 127.0.0.1)
   - DB_USER: Database username (default: root)
   - DB_PASSWORD: Database password
   - DB_NAME: Database name (default: blood_sugar_db)
   - DB_PORT: Not explicitly set, uses MySQL default 3306


2. CONNECTION METHOD
--------------------
   def connect(self):
       """Establish database connection"""
       try:
           self.connection = mysql.connector.connect(
               host=os.environ.get('DB_HOST', '127.0.0.1'),
               user=os.environ.get('DB_USER', 'root'),
               password=os.environ.get('DB_PASSWORD'),
               database=os.environ.get('DB_NAME', 'blood_sugar_db'),
               autocommit=False
           )

Key Features:
   ✓ Environment variable configuration for security
   ✓ Fallback to default values for development
   ✓ Connection validation with is_connected() check
   ✓ Comprehensive error logging


3. CONNECTION RESILIENCE
-------------------------
Auto-reconnection mechanism:

   def _get_cursor(self):
       """Get a cursor, reconnecting if necessary"""
       try:
           if not self.connection or not self.connection.is_connected():
               self.connect()
       except:
           self.connect()
       return self.connection.cursor(dictionary=True, buffered=True)

Benefits:
   ✓ Automatic reconnection on connection loss
   ✓ Dictionary cursors for easy data access
   ✓ Buffered results to prevent unread results errors


================================================================================
DATABASE SCHEMA OVERVIEW
================================================================================

CORE TABLES
-----------

1. USERS (Central authentication table)
   ├── user_id (PRIMARY KEY)
   ├── email (UNIQUE)
   ├── password_hash
   ├── first_name
   ├── last_name
   ├── role (patient/specialist/staff/admin)
   ├── created_at
   └── profile_image_path

2. PATIENTS (Patient-specific data)
   ├── patient_id (PRIMARY KEY)
   ├── user_id (FOREIGN KEY → users)
   ├── health_care_number
   ├── date_of_birth
   ├── gender
   └── assigned_specialist_id (FOREIGN KEY → specialists)

3. SPECIALISTS (Healthcare provider data)
   ├── specialist_id (PRIMARY KEY)
   ├── user_id (FOREIGN KEY → users)
   ├── license_id (Professional license number)
   ├── specialization
   └── clinic_address

4. STAFF (Administrative staff data)
   ├── staff_id (PRIMARY KEY)
   ├── user_id (FOREIGN KEY → users)
   ├── employee_id
   └── department

5. READINGS (Blood sugar measurements)
   ├── reading_id (PRIMARY KEY)
   ├── user_id (FOREIGN KEY → users)
   ├── value (glucose level)
   ├── unit (mg/dL or mmol/L)
   ├── date_time
   ├── fasting (boolean)
   ├── food_intake
   ├── activity
   ├── symptoms
   ├── notes
   └── status (normal/high/low/prediabetic)

6. THRESHOLDS (Personalized glucose targets)
   ├── threshold_id (PRIMARY KEY)
   ├── user_id (FOREIGN KEY → users)
   ├── status (fasting/postprandial/bedtime)
   ├── min_value
   └── max_value

7. AI_INSIGHTS (Machine learning analysis)
   ├── insight_id (PRIMARY KEY)
   ├── user_id (FOREIGN KEY → users)
   ├── pattern (identified pattern description)
   ├── suggestion (AI recommendation)
   ├── confidence (0.0 to 1.0)
   ├── created_at
   └── is_read (boolean)

8. ALERTS (Automated warnings)
   ├── alert_id (PRIMARY KEY)
   ├── user_id (FOREIGN KEY → users)
   ├── reason (alert description)
   ├── specialist_id (optional notification target)
   ├── created_at
   └── resolved (boolean)

9. DIET_RECOMMENDATIONS (Nutritional guidance)
   ├── recommendation_id (PRIMARY KEY)
   ├── condition_name (diabetes/heart disease/etc.)
   ├── meal_type (breakfast/lunch/dinner/snack)
   ├── food_item
   ├── portion_size
   └── nutritional_benefits

10. MEDICAL_RECORDS (Document storage metadata)
    ├── record_id (PRIMARY KEY)
    ├── user_id (FOREIGN KEY → users)
    ├── file_path
    ├── file_type
    ├── uploaded_at
    └── description


================================================================================
DATABASE OPERATIONS FLOW
================================================================================

TYPICAL TRANSACTION FLOW
-------------------------

1. USER REGISTRATION
   ┌─────────────────────────────────────────────────────┐
   │ 1. Hash password using hashlib.sha256              │
   │ 2. INSERT into users table                         │
   │ 3. Get last_insert_id() for user_id               │
   │ 4. INSERT into role-specific table                 │
   │    (patients/specialists/staff)                    │
   │ 5. COMMIT transaction                              │
   └─────────────────────────────────────────────────────┘

2. ADDING BLOOD SUGAR READING
   ┌─────────────────────────────────────────────────────┐
   │ 1. Validate user authentication                    │
   │ 2. INSERT reading into readings table              │
   │ 3. Check against user's thresholds                 │
   │ 4. If abnormal:                                    │
   │    a. Create alert in alerts table                 │
   │    b. Trigger ML analysis                          │
   │    c. Generate AI insight                          │
   │    d. Notify assigned specialist                   │
   │ 5. COMMIT transaction                              │
   └─────────────────────────────────────────────────────┘

3. GENERATING INSIGHTS (ML Integration)
   ┌─────────────────────────────────────────────────────┐
   │ 1. SELECT recent readings for user                 │
   │ 2. Convert to pandas DataFrame                     │
   │ 3. Analyze patterns (food, activity, time)        │
   │ 4. Generate personalized recommendations          │
   │ 5. INSERT insights into ai_insights table         │
   │ 6. COMMIT and return to user                      │
   └─────────────────────────────────────────────────────┘


================================================================================
CONNECTION POOLING & PERFORMANCE
================================================================================

CURRENT IMPLEMENTATION
----------------------
- Single connection per Database instance
- Reconnection on demand via _get_cursor()
- No explicit connection pooling (suitable for current scale)

Performance Optimizations:
   ✓ Dictionary cursors reduce data processing overhead
   ✓ Buffered cursors prevent unread results
   ✓ Explicit connection validation before queries
   ✓ Proper error handling and logging

SCALABILITY CONSIDERATIONS
---------------------------
For production deployment with high traffic:
   - Implement connection pooling with mysql.connector.pooling
   - Use SQLAlchemy ORM for connection management
   - Consider read replicas for reporting queries
   - Implement query caching for frequent reads


================================================================================
SECURITY MEASURES
================================================================================

PASSWORD SECURITY
-----------------
- Passwords hashed using SHA-256 before storage
- No plain text passwords in database
- Hash generation: hashlib.sha256(password.encode()).hexdigest()

CONNECTION SECURITY
-------------------
- Environment variables for credentials (not hardcoded)
- No password stored in version control
- Prepared statements prevent SQL injection
- All queries use parameterized inputs

Example of safe query:
   cursor.execute("SELECT * FROM users WHERE email = %s", (email,))
   # NOT: f"SELECT * FROM users WHERE email = '{email}'"


================================================================================
BACKUP & MAINTENANCE
================================================================================

DATABASE INITIALIZATION
-----------------------
Initial schema created from: backend/blood_sugar_db.sql

Contains:
   - All table definitions
   - Foreign key relationships
   - Indexes for performance
   - Initial admin accounts

To restore database:
   mysql -u root -p blood_sugar_db < backend/blood_sugar_db.sql


================================================================================
TROUBLESHOOTING GUIDE
================================================================================

COMMON ISSUES
-------------

Issue: "Access denied for user 'root'@'localhost'"
Solution: 
   - Check DB_PASSWORD environment variable
   - Verify MySQL user credentials
   - Grant privileges: GRANT ALL ON blood_sugar_db.* TO 'root'@'localhost'

Issue: "Can't connect to MySQL server on '127.0.0.1'"
Solution:
   - Ensure MySQL service is running
   - Check port 3306 is not blocked by firewall
   - Verify DB_HOST environment variable

Issue: "Unknown database 'blood_sugar_db'"
Solution:
   - Create database: CREATE DATABASE blood_sugar_db;
   - Import schema from blood_sugar_db.sql

Issue: Unread result warnings
Solution:
   - Already handled with buffered cursors
   - Call cursor.fetchall() after queries that might have results


================================================================================
DEVELOPMENT WORKFLOW
================================================================================

LOCAL SETUP
-----------
1. Install MySQL/MariaDB
2. Create database: CREATE DATABASE blood_sugar_db;
3. Import schema: mysql -u root -p blood_sugar_db < blood_sugar_db.sql
4. Set environment variables (or use defaults)
5. Run Flask app: python app.py

Environment Variables (Optional):
   export DB_HOST=127.0.0.1
   export DB_USER=root
   export DB_PASSWORD=your_password
   export DB_NAME=blood_sugar_db


================================================================================
CONCLUSION
================================================================================

The database architecture uses MySQL with a well-structured relational schema
that supports all system features including authentication, medical data 
tracking, AI insights, and multi-role user management. The connection 
mechanism is robust with automatic reconnection and comprehensive error 
handling, suitable for a healthcare monitoring application.

Key Strengths:
   ✓ Secure password handling
   ✓ Flexible connection configuration
   ✓ Automatic reconnection handling
   ✓ Comprehensive data relationships
   ✓ Ready for ML integration
   ✓ Multi-user role support

================================================================================
