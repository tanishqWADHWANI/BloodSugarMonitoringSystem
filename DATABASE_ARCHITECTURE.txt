================================================================================
              DATABASE ARCHITECTURE & CONNECTION GUIDE
================================================================================
                Blood Sugar Monitoring System
                Technical Documentation
================================================================================

OVERVIEW
--------
The system uses MySQL/MariaDB as the primary database for storing all 
application data including user accounts, blood sugar readings, medical 
records, thresholds, and AI-generated insights.

Database Name: blood_sugar_db
Database Port: 3306 (MySQL default)
Connection Type: Direct connection using mysql-connector-python


================================================================================
DATABASE CONNECTION PROCESS
================================================================================

1. CONNECTION INITIALIZATION
-----------------------------
Location: backend/models.py - Database class

The Database class establishes connection on initialization:

   def __init__(self):
       """Initialize database connection"""
       self.connection = None
       self.connect()

Environment Variables Used:
   - DB_HOST: Database server address (default: 127.0.0.1)
   - DB_USER: Database username (default: root)
   - DB_PASSWORD: Database password
   - DB_NAME: Database name (default: blood_sugar_db)
   - DB_PORT: Not explicitly set, uses MySQL default 3306


2. CONNECTION METHOD - LINE BY LINE EXPLANATION
-----------------------------------------------

```python
def connect(self):
    """Establish database connection"""
    
    # LINE 1: Begin try block for error handling
    # Connection can fail: wrong password, MySQL not running, etc.
    try:
        # LINE 2-7: Create database connection
        # mysql.connector.connect() establishes TCP connection to MySQL server
        self.connection = mysql.connector.connect(
            
            # LINE 3: Database server address
            # os.environ.get('DB_HOST', '127.0.0.1') explained:
            #   - os.environ.get() reads environment variable
            #   - First arg: variable name to read (DB_HOST)
            #   - Second arg: default if not set ('127.0.0.1')
            # 127.0.0.1 = localhost = your own computer
            # Set environment: Windows: set DB_HOST=192.168.1.100
            #                 Linux/Mac: export DB_HOST=192.168.1.100
            host=os.environ.get('DB_HOST', '127.0.0.1'),
            
            # LINE 4: Database username
            # 'root' is MySQL administrator account (full privileges)
            # Production: Use limited-privilege account for security
            # Example: CREATE USER 'app_user'@'localhost' IDENTIFIED BY 'pass';
            user=os.environ.get('DB_USER', 'root'),
            
            # LINE 5: Database password
            # NO DEFAULT for security - must set environment variable
            # os.environ.get('DB_PASSWORD') returns None if not set
            # Connection fails if password is None → Intentional security
            # Set: Windows: set DB_PASSWORD=mySecurePassword123
            #      Linux/Mac: export DB_PASSWORD=mySecurePassword123
            password=os.environ.get('DB_PASSWORD'),
            
            # LINE 6: Database name
            # Connects to specific database (MySQL can have multiple)
            # Like opening specific folder in file system
            # 'blood_sugar_db' is our application's database
            database=os.environ.get('DB_NAME', 'blood_sugar_db'),
            
            # LINE 7: Disable autocommit
            # autocommit=False means changes aren't saved automatically
            # Must call connection.commit() to save changes
            # Allows transactions: multiple operations succeed or fail together
            # Example: Insert reading AND create alert → both or neither
            autocommit=False
        )
        
        # LINE 8: Check if connection successful
        # is_connected() returns True if connection active
        # Can be False even after connect() if network issue
        if self.connection.is_connected():
            # LINE 9: Log success message
            # logger.info() writes to log file with timestamp
            # Example log: "2025-11-24 10:30:15 - INFO - Database connection established"
            logger.info("Database connection established")
            
    # LINE 10: Catch MySQL-specific errors
    # Error class from mysql.connector (not generic Exception)
    # Includes: authentication failed, database doesn't exist, etc.
    except Error as e:
        # LINE 11: Log error with details
        # f-string inserts error message: f"...error: {e}"
        # Example: "Database connection error: Access denied for user 'root'@'localhost'"
        logger.error(f"Database connection error: {e}")
        
        # LINE 12: Re-raise the exception
        # raise stops program execution
        # In production, might want to retry instead of stopping
        # For now: Can't run without database → Stop application
        raise
```

CONNECTION PARAMETERS EXPLAINED:
--------------------------------

1. host='127.0.0.1'
   - IP address of database server
   - 127.0.0.1 = localhost = your computer
   - For remote database: '192.168.1.100' or 'db.example.com'
   - Port 3306 (MySQL default) used automatically

2. user='root'
   - MySQL username to log in as
   - 'root' = administrator (full access)
   - Production: CREATE USER 'limited_user'@'localhost';
   - Grant only needed privileges: GRANT SELECT, INSERT, UPDATE ON ...

3. password=os.environ.get('DB_PASSWORD')
   - Retrieved from environment variable (NOT hardcoded)
   - Keeps passwords out of source code / version control
   - If not set → None → connection fails → Security by design

4. database='blood_sugar_db'
   - Which database to use (server can host multiple)
   - Must exist: CREATE DATABASE blood_sugar_db;
   - Can switch later: connection.cursor().execute("USE other_db")

5. autocommit=False
   - Manual transaction control
   - Changes not saved until connection.commit()
   - Rollback possible: connection.rollback()
   - Transaction example:
     ```python
     try:
         cursor.execute("INSERT INTO readings ...")
         cursor.execute("INSERT INTO alerts ...")
         connection.commit()  # Both saved
     except:
         connection.rollback()  # Neither saved
     ```

Key Features:
   ✓ Environment variable configuration for security
   ✓ Fallback to default values for development
   ✓ Connection validation with is_connected() check
   ✓ Comprehensive error logging


3. CONNECTION RESILIENCE
-------------------------
Auto-reconnection mechanism:

   def _get_cursor(self):
       """Get a cursor, reconnecting if necessary"""
       try:
           if not self.connection or not self.connection.is_connected():
               self.connect()
       except:
           self.connect()
       return self.connection.cursor(dictionary=True, buffered=True)

Benefits:
   ✓ Automatic reconnection on connection loss
   ✓ Dictionary cursors for easy data access
   ✓ Buffered results to prevent unread results errors


================================================================================
DATABASE SCHEMA OVERVIEW
================================================================================

CORE TABLES
-----------

1. USERS (Central authentication table)
   ├── user_id (PRIMARY KEY)
   ├── email (UNIQUE)
   ├── password_hash
   ├── first_name
   ├── last_name
   ├── role (patient/specialist/staff/admin)
   ├── created_at
   └── profile_image_path

2. PATIENTS (Patient-specific data)
   ├── patient_id (PRIMARY KEY)
   ├── user_id (FOREIGN KEY → users)
   ├── health_care_number
   ├── date_of_birth
   ├── gender
   └── assigned_specialist_id (FOREIGN KEY → specialists)

3. SPECIALISTS (Healthcare provider data)
   ├── specialist_id (PRIMARY KEY)
   ├── user_id (FOREIGN KEY → users)
   ├── license_id (Professional license number)
   ├── specialization
   └── clinic_address

4. STAFF (Administrative staff data)
   ├── staff_id (PRIMARY KEY)
   ├── user_id (FOREIGN KEY → users)
   ├── employee_id
   └── department

5. READINGS (Blood sugar measurements)
   ├── reading_id (PRIMARY KEY)
   ├── user_id (FOREIGN KEY → users)
   ├── value (glucose level)
   ├── unit (mg/dL or mmol/L)
   ├── date_time
   ├── fasting (boolean)
   ├── food_intake
   ├── activity
   ├── symptoms
   ├── notes
   └── status (normal/high/low/prediabetic)

6. THRESHOLDS (Personalized glucose targets)
   ├── threshold_id (PRIMARY KEY)
   ├── user_id (FOREIGN KEY → users)
   ├── status (fasting/postprandial/bedtime)
   ├── min_value
   └── max_value

7. AI_INSIGHTS (Machine learning analysis)
   ├── insight_id (PRIMARY KEY)
   ├── user_id (FOREIGN KEY → users)
   ├── pattern (identified pattern description)
   ├── suggestion (AI recommendation)
   ├── confidence (0.0 to 1.0)
   ├── created_at
   └── is_read (boolean)

8. ALERTS (Automated warnings)
   ├── alert_id (PRIMARY KEY)
   ├── user_id (FOREIGN KEY → users)
   ├── reason (alert description)
   ├── specialist_id (optional notification target)
   ├── created_at
   └── resolved (boolean)

9. DIET_RECOMMENDATIONS (Nutritional guidance)
   ├── recommendation_id (PRIMARY KEY)
   ├── condition_name (diabetes/heart disease/etc.)
   ├── meal_type (breakfast/lunch/dinner/snack)
   ├── food_item
   ├── portion_size
   └── nutritional_benefits

10. MEDICAL_RECORDS (Document storage metadata)
    ├── record_id (PRIMARY KEY)
    ├── user_id (FOREIGN KEY → users)
    ├── file_path
    ├── file_type
    ├── uploaded_at
    └── description


================================================================================
DATABASE OPERATIONS FLOW
================================================================================

TYPICAL TRANSACTION FLOW
-------------------------

1. USER REGISTRATION
   ┌─────────────────────────────────────────────────────┐
   │ 1. Hash password using hashlib.sha256              │
   │ 2. INSERT into users table                         │
   │ 3. Get last_insert_id() for user_id               │
   │ 4. INSERT into role-specific table                 │
   │    (patients/specialists/staff)                    │
   │ 5. COMMIT transaction                              │
   └─────────────────────────────────────────────────────┘

2. ADDING BLOOD SUGAR READING
   ┌─────────────────────────────────────────────────────┐
   │ 1. Validate user authentication                    │
   │ 2. INSERT reading into readings table              │
   │ 3. Check against user's thresholds                 │
   │ 4. If abnormal:                                    │
   │    a. Create alert in alerts table                 │
   │    b. Trigger ML analysis                          │
   │    c. Generate AI insight                          │
   │    d. Notify assigned specialist                   │
   │ 5. COMMIT transaction                              │
   └─────────────────────────────────────────────────────┘

3. GENERATING INSIGHTS (ML Integration)
   ┌─────────────────────────────────────────────────────┐
   │ 1. SELECT recent readings for user                 │
   │ 2. Convert to pandas DataFrame                     │
   │ 3. Analyze patterns (food, activity, time)        │
   │ 4. Generate personalized recommendations          │
   │ 5. INSERT insights into ai_insights table         │
   │ 6. COMMIT and return to user                      │
   └─────────────────────────────────────────────────────┘


================================================================================
CONNECTION POOLING & PERFORMANCE
================================================================================

CURRENT IMPLEMENTATION
----------------------
- Single connection per Database instance
- Reconnection on demand via _get_cursor()
- No explicit connection pooling (suitable for current scale)

Performance Optimizations:
   ✓ Dictionary cursors reduce data processing overhead
   ✓ Buffered cursors prevent unread results
   ✓ Explicit connection validation before queries
   ✓ Proper error handling and logging

SCALABILITY CONSIDERATIONS
---------------------------
For production deployment with high traffic:
   - Implement connection pooling with mysql.connector.pooling
   - Use SQLAlchemy ORM for connection management
   - Consider read replicas for reporting queries
   - Implement query caching for frequent reads


================================================================================
SECURITY MEASURES
================================================================================

PASSWORD SECURITY
-----------------
- Passwords hashed using SHA-256 before storage
- No plain text passwords in database
- Hash generation: hashlib.sha256(password.encode()).hexdigest()

CONNECTION SECURITY
-------------------
- Environment variables for credentials (not hardcoded)
- No password stored in version control
- Prepared statements prevent SQL injection
- All queries use parameterized inputs

Example of safe query:
   cursor.execute("SELECT * FROM users WHERE email = %s", (email,))
   # NOT: f"SELECT * FROM users WHERE email = '{email}'"


================================================================================
BACKUP & MAINTENANCE
================================================================================

DATABASE INITIALIZATION
-----------------------
Initial schema created from: backend/blood_sugar_db.sql

Contains:
   - All table definitions
   - Foreign key relationships
   - Indexes for performance
   - Initial admin accounts

To restore database:
   mysql -u root -p blood_sugar_db < backend/blood_sugar_db.sql


================================================================================
TROUBLESHOOTING GUIDE
================================================================================

COMMON ISSUES
-------------

Issue: "Access denied for user 'root'@'localhost'"
Solution: 
   - Check DB_PASSWORD environment variable
   - Verify MySQL user credentials
   - Grant privileges: GRANT ALL ON blood_sugar_db.* TO 'root'@'localhost'

Issue: "Can't connect to MySQL server on '127.0.0.1'"
Solution:
   - Ensure MySQL service is running
   - Check port 3306 is not blocked by firewall
   - Verify DB_HOST environment variable

Issue: "Unknown database 'blood_sugar_db'"
Solution:
   - Create database: CREATE DATABASE blood_sugar_db;
   - Import schema from blood_sugar_db.sql

Issue: Unread result warnings
Solution:
   - Already handled with buffered cursors
   - Call cursor.fetchall() after queries that might have results


================================================================================
DEVELOPMENT WORKFLOW
================================================================================

LOCAL SETUP
-----------
1. Install MySQL/MariaDB
2. Create database: CREATE DATABASE blood_sugar_db;
3. Import schema: mysql -u root -p blood_sugar_db < blood_sugar_db.sql
4. Set environment variables (or use defaults)
5. Run Flask app: python app.py

Environment Variables (Optional):
   export DB_HOST=127.0.0.1
   export DB_USER=root
   export DB_PASSWORD=your_password
   export DB_NAME=blood_sugar_db


================================================================================
CONCLUSION
================================================================================

The database architecture uses MySQL with a well-structured relational schema
that supports all system features including authentication, medical data 
tracking, AI insights, and multi-role user management. The connection 
mechanism is robust with automatic reconnection and comprehensive error 
handling, suitable for a healthcare monitoring application.

Key Strengths:
   ✓ Secure password handling
   ✓ Flexible connection configuration
   ✓ Automatic reconnection handling
   ✓ Comprehensive data relationships
   ✓ Ready for ML integration
   ✓ Multi-user role support

================================================================================
